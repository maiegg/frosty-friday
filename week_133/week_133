-- Create table
CREATE OR REPLACE TABLE orders (
    order_id NUMBER AUTOINCREMENT,
    mathematician_name STRING,
    pie_type STRING,
    price FLOAT
);

-- Create procedure for uploading with parameters
CREATE OR REPLACE PROCEDURE insert_pie_order(
    name STRING,
    pie STRING,
    price FLOAT
)
RETURNS STRING
LANGUAGE SQL
AS
$$
BEGIN
    INSERT INTO orders (mathematician_name, pie_type, price)
    VALUES (:name, :pie, :price);
    
    RETURN 'Success';
END;
$$;

-- This is synchronous:
CALL insert_pie_order('Erdos','hungary4pie', 1.619);
CALL insert_pie_order('Georg Cantor' ,'Infinite Layer Pie', 17.77);


-- How to do async?
-- Following this: https://www.snowflake.com/en/engineering-blog/sql-stored-procedures-async-execution/
CREATE OR REPLACE PROCEDURE async_pie_time()
RETURNS STRING
LANGUAGE SQL
AS
BEGIN
    
    LET total INTEGER := 0;

        -- fire child jobs to ascynchronoulsy insert into target_table -- 
    ASYNC (
        INSERT INTO ORDERS(mathematician_name, pie_type, price) 
        VALUES ('Erdos','hungary4pie', 1.619)
    ); 
    total := total + 1;

    ASYNC (
        INSERT INTO ORDERS(mathematician_name, pie_type, price)
        VALUES ('Georg Cantor' ,'Infinite Layer Pie', 17.77)
    ); 
    total := total + 1;
    

    -- Ensures all insertions finish before returning ---
    AWAIT ALL;

    RETURN 'Done, INSERTED: ' || total;
END;

CALL async_pie_time();


-- What if each batch of orders exists in a table?
-- Suppose we have a table loaded from JSON of these 3-tuples where each row is an object with named keys
create or replace table wk133_json as 
SELECT 
  value as raw_json
FROM TABLE(
  FLATTEN(
    ARRAY_CONSTRUCT(
      OBJECT_CONSTRUCT('mathematician_name', 'Pierre-Simon Laplace', 'pie_type', 'Banana Cream Pie', 'price', 12.25),
      OBJECT_CONSTRUCT('mathematician_name', 'Blaise Pascal', 'pie_type', 'Lemon Meringue Pie', 'price', 11.99),
      OBJECT_CONSTRUCT('mathematician_name', 'Hypatia', 'pie_type', 'Key Lime Pie', 'price', 10.75),
      OBJECT_CONSTRUCT('mathematician_name', 'John von Neumann', 'pie_type', 'Pear Pie', 'price', 13.99),
      OBJECT_CONSTRUCT('mathematician_name', 'Joseph Fourier', 'pie_type', 'Apricot Pie', 'price', 14.25)
    )
  )
);

-- to load each row asynchronously:

CREATE OR REPLACE PROCEDURE async_pie_time()
RETURNS STRING
LANGUAGE PYTHON
RUNTIME_VERSION = '3.8'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'run'
AS
$$
import json
from snowflake.snowpark import Session

def run(session: Session) -> str:
    total = 0

    # Read the raw_json column from the input table
    df = session.table("wk133_json").select("raw_json")
    rows = df.collect()

    for row in rows:
        try:
            data = json.loads(row["RAW_JSON"])
            name = data["mathematician_name"]
            pie = data["pie_type"]
            price = data["price"]

            # Insert into ORDERS table
            session.sql(f"""
                INSERT INTO ORDERS(mathematician_name, pie_type, price)
                VALUES ('{name}', '{pie}', {price})
            """).collect()

            total += 1
        except Exception as e:
            # Optionally log or raise error
            raise Exception(f"Error processing row {row['RAW_JSON']}: {e}")

    return f"Done, INSERTED: {total}"
$$;


call async_pie_time();
