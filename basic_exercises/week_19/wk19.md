**Making a date_dim**
The trickiest part of getting this started, for me, was generating the base list of dates in a way that seemed practical and realistic. To me, that meant with a date range as opposed to a hard-coded number of rows. 

I used this recursive CTE to accomplish that: 
```
WITH RECURSIVE CalendarDates AS (
SELECT DATE('2000-01-01') AS calendar_date
UNION ALL
SELECT DATEADD(DAY, 1, calendar_date)
FROM CalendarDates
WHERE calendar_date <= '2100-01-01'
)
```
After which creating the date_dim is only a matter of looking up the right date functions in Snowflake:
```
select 
    calendar_date
    , YEAR(calendar_date) as calendar_year
    , MONTHNAME(calendar_date) as month_abbrev
    , TO_CHAR(calendar_date,'MMMM') as month_name
    , MONTH(calendar_date) AS month_number
    , DAY(calendar_date) AS day_of_month
    , DAYOFWEEK(calendar_date) AS day_of_week -- 0-6, 0 = Sunday by default 
    , WEEK(calendar_date) AS week_of_year
    , DAYOFYEAR(calendar_date) AS day_of_year
from CALENDARDATES
;
```
For the function, I opted for a SQL UDF. (Python numpy has a builtin `busdays` function, but thinking of an algorithm in SQL seemed like a more interesting challenging than futzing with Python handlers and library imports).

I repeated the CTE to generate the list of dates between a range (start date to end date, the function arguments), and counted only Monday through Friday inclusive as business days - no holidays required. 

```
create function weekdays_between_dates(start_date date, end_date date)
    RETURNS number
    AS 
    $$
    WITH RECURSIVE CalendarDates AS (
    SELECT DATE(start_date) AS calendar_date
    UNION ALL
    SELECT DATEADD(DAY, 1, calendar_date)
    FROM CalendarDates
    WHERE calendar_date <= end_date
    )
    select sum(
    case when DAYOFWEEK(calendar_date) in (6,0) then 0 else 1 end
    )
    from CalendarDates
    $$
;

-- example usage:
select weekdays_between_dates('2025-04-26', '2025-05-02');
```